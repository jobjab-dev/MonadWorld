# MonadWorld Project Documentation\n\n## 1. Overview\n\nMonadWorld is a Web3 project centered around Lilnad NFTs, unique Soul-Bound Tokens (SBTs) that allow users to collect, earn scores, and compete for rewards within an interactive ecosystem on the Monad blockchain. The project aims to deliver an engaging pixel art experience with a focus on community and a rewarding game economy.\n\nKey objectives include:\n*   Providing a fun and engaging NFT collection experience.\n*   Implementing a fair and exciting reward system through seasonal snapshots and Love Token distribution.\n*   Building a secure and efficient platform on the Monad Testnet, with plans for Mainnet deployment.\n\n## 2. Architecture\n\n### 2.1 Frontend\n\n*   **Technology:** Next.js (React Framework), TypeScript, Tailwind CSS, wagmi (for Smart Contract interaction), viem.\n*   **Key Pages:**\n    *   **Home (`/`):** Landing page, project overview, game preview, call to actions.\n    *   **Mint (`/mint`):** Interface for users to mint new Lilnad NFTs (single and bulk packs).\n    *   **Collect (`/collect`):** Displays the user\'s owned Lilnad NFTs, allowing them to view details and manage their collection (e.g., collect scores).\n    *   **World (`/world`):** A 2D pixel art representation where users see their Lilnad NFTs (as frogs/characters) moving around, reflecting their collection size and ranks.\n    *   **Leaderboard (`/leaderboard`):** (Planned) To display rankings based on scores or other metrics.\n*   **State Management:** Primarily React Context API and component-level state.\n*   **Smart Contract Interaction:** Uses wagmi hooks (`useReadContract`, `useWriteContract`) for direct interaction with LilnadNFT, LoveToken, and LoveDistributor contracts for fetching data and sending transactions.\n*   **Backend Interaction:** Calls backend APIs for aggregated data, metadata, and potentially off-chain calculations or data not suitable for direct contract calls.\n\n### 2.2 Backend\n\n*   **Technology:** Node.js, Express.js, Prisma (ORM), PostgreSQL (Database), TypeScript.\n*   **Directory Structure:** `src` (main logic), `prisma` (schema, migrations), `abi` (contract ABIs).\n*   **Key Files:**\n    *   `src/index.ts`: Main API server, request handling, on-chain data enrichment.\n    *   `src/indexer.ts`: Listens to Smart Contract events (`RevealAndMint`, planned: `Transfer`) and updates the PostgreSQL database.\n    *   `src/config.ts`: Configurations like RPC URLs, contract addresses, ABI imports.\n    *   `prisma/schema.prisma`: Defines the database schema for models like `LilnadNft`, `User`, etc.\n*   **API Endpoints:**\n    *   `/api/nfts/owner/:ownerAddress`: Fetches a user\'s NFTs, initially from the DB (via indexer), then enriches with live on-chain data (`sbtInfo`) and calculates additional fields.\n    *   `/api/metadata/lilnad/:tokenId`: Serves ERC721 compliant metadata for Lilnad NFTs, constructing image URLs dynamically.\n    *   `/leaderboard`: (Planned/Existing) Serves leaderboard data, likely from snapshotted scores in the DB.\n*   **Indexer Logic:** The indexer currently listens for `RevealAndMint` events to populate the `LilnadNft` table. **Crucial pending update: It needs to listen to `Transfer` events to keep `ownerAddress` in the DB accurate.**\n\n### 2.3 Smart Contracts\n\n#### 2.3.1 `LilnadNFT.sol` (ERC721 SBT)\n\n*   **Overview:** The core Soul-Bound Token contract. Users mint these NFTs, which accrue scores over time.\n*   **Key Features:**\n    *   Commit-Reveal minting mechanism for randomness in rank assignment.\n    *   Multiple minting pack options (single, 10+1, 25+3 after planned reduction).\n    *   SBT mechanics: NFTs have a lifecycle, accrue scores (`collected`), and can become "dead" after their accrual period (`T` in `RankInfo`).\n    *   Score collection function (`collect(tokenId)`).\n    *   Dev fee (5%) accumulated in `devPool` from minting fees.\n*   **Data Structures:**\n    *   `RankInfo {S, T}`: Score accrual rate (S) and total accrual time (T) per rank.\n    *   `SBTInfo {startTimestamp, lastCollect, collected, isDead, rank}`: Per-token SBT data.\n    *   `CommitInfo {commitment, blockNumber}`: For commit-reveal process.\n*   **View Functions:**\n    *   `sbtInfo(tokenId)`: Returns SBT data for a token.\n    *   `tokenURI(tokenId)`: Returns metadata URI.\n    *   `rankData(rankId)`: Returns S and T for a rank.\n    *   `getNftsSummary(address _owner)`: Returns total owned NFT count and count per rank (for live NFTs).\n    *   `getOwnedLiveTokenIds(address _owner)`: (Planned/Suggested) Returns an array of token IDs owned by `_owner` that are still live.\n    *   `(Planned)` `getNftDetails(tokenId)`: To return SBTInfo, expirationTimestamp, and collectableScore for a specific NFT.\n*   **Events:** `RevealAndMint`, `Collected`, `Died`, `Transfer` (standard ERC721).\n\n#### 2.3.2 `LoveToken.sol` (ERC20)\n\n*   **Overview:** An ERC20 token ("Love Token", LOVE) used as a reward currency.\n*   **Supply:** Unlimited, minted by the `owner` (LoveDistributor contract).\n*   **Key Functions:**\n    *   `mint(address to, uint256 amount)`: Owner-only minting.\n    *   `burn(uint256 amount)`: Allows users to burn their LOVE.\n\n#### 2.3.3 `LoveDistributor.sol`\n\n*   **Overview:** Manages seasonal reward distribution of LOVE tokens.\n*   **Dependencies:** Interacts with `LilnadNFT` (to potentially receive MON from `devPool`) and `LoveToken` (to mint LOVE).\n*   **Key Functions:**\n    *   `executeSeason(bytes32 root, uint256 totalLoveForUsersExpected)`: Owner-only function to start a new reward season. It uses MON from its balance to mint LOVE (MON\*2), reserves some for user distribution (based on Merkle root) and some for LP.\n    *   `claim(uint256 seasonId, uint256 amount, bytes32[] calldata proof)`: Allows users to claim their LOVE rewards using a Merkle proof.\n    *   `withdrawEth(amount)`, `withdrawLove(amount)`: Owner-only functions to withdraw MON and LOVE for manual LP creation.\n*   **Mechanism:** Uses Merkle Trees for efficient and verifiable reward claims.\n\n## 3. Data Flow Examples\n\n*   **(To be detailed later based on final implementations)**\n    *   User Mints an NFT (Commit -> Reveal -> DB Update via Indexer)\n    *   User Views Collect Page (Frontend -> Smart Contract Views / (optional) Backend Cache)\n    *   User Views World Page (Frontend -> Smart Contract View `getNftsSummary`)\n    *   Reward Distribution (Off-chain Snapshot & Merkle Root -> `executeSeason` -> User Claim)\n\n## 4. Key Features & Logic\n\n*   **Minting & Rank Assignment:**\n    *   Utilizes a Commit-Reveal scheme with `blockhash` and `block.prevrandao` for randomness to prevent front-running and rank prediction.\n    *   Penalties for not revealing in time (results in the lowest rank NFT).\n*   **Soul-Bound Token (SBT) Mechanics:**\n    *   NFTs (Lilnads) accrue scores over a defined period (`T` based on rank).\n    *   Users can `collect()` accrued scores.\n    *   NFTs become "dead" after their accrual period or if all scores are collected.\n*   **Game Rules & Reward System (Seasonal):**\n    *   **Snapshots:** Occur every 7 days, based on scores collected by users.\n    *   **Reward Pool:** Funded by MON from LilnadNFT minting fees (95% after 5% dev fee is set aside). This MON is transferred to the `LoveDistributor` contract.\n    *   **Love Token Minting:** For each season, `LoveDistributor` mints LOVE tokens at a rate of 2 LOVE per 1 MON in its reward pool for that season.\n    *   **Liquidity Provision (LP):** A portion of the minted LOVE (equal to the MON used for the season) and the MON itself are designated for creating a MON/LOVE LP (e.g., on a DEX, with a 1:1 MON:LOVE ratio, target range 0.01%). This is currently a manual withdrawal step for the owner.\n    *   **Player Rewards:** The remaining LOVE tokens are distributed to players.\n    *   **Eligibility & Tiers:** Only the top 70% of players (based on collected scores in the snapshot period) are eligible for rewards.\n    *   **Lottery System:** 1 collected score acts as 1 "ticket". Rewards are tiered (like a lottery). A player can only win one prize per season, but having more tickets increases the chance of winning a higher-tier prize. The exact tier structure and prize amounts are determined off-chain when generating the Merkle root for distribution.\n*   **(Planned) NFT Expiration:** Users will be able to see when their NFTs are due to expire (stop accruing score) via a view function and UI updates.\n*   **(Planned) Collect All:** A function to allow users to collect scores from multiple NFTs in a more gas-efficient way (potentially batched).\n\n## 5. Setup & Running the Project\n\n*   **Prerequisites:**\n    *   Node.js (e.g., v18+)\n    *   Yarn or npm\n    *   PostgreSQL server\n    *   Git\n*   **Environment Variables (`.env.local` for both frontend and backend):**\n    *   `DATABASE_URL`: PostgreSQL connection string (for backend).\n    *   `RPC_URL`: URL for Monad Testnet RPC node (for backend and frontend).\n    *   `LILNAD_NFT_ADDRESS`: Deployed LilnadNFT contract address (for backend and frontend).\n    *   `LOVE_TOKEN_ADDRESS`: (Future) Deployed LoveToken contract address.\n    *   `LOVE_DISTRIBUTOR_ADDRESS`: (Future) Deployed LoveDistributor contract address.\n    *   `INDEXER_START_BLOCK`: Block number for the indexer to start from (for backend).\n    *   `RUN_INDEXER`: Set to `true` to enable the indexer (for backend).\n    *   `FRONTEND_BASE_URL`: Public base URL of the frontend (for backend metadata).\n    *   `BACKEND_PUBLIC_URL`: Public base URL of the backend (for constructing metadata URIs from backend).\n    *   `PORT`: Port for the backend server (e.g., 3001).\n    *   (Frontend may also use Next.js specific env vars like `NEXT_PUBLIC_...`)\n*   **Installation:**\n    1.  Clone the repository.\n    2.  Backend: `cd backend && npm install` (or `yarn install`)\n    3.  Frontend: `cd frontend && npm install` (or `yarn install`)\n*   **Running Development Servers:**\n    *   Backend API: `cd backend && npm run dev`\n    *   Backend Indexer: Ensure `RUN_INDEXER=true` in `backend/.env.local`. The indexer starts with the backend server.\n    *   Frontend: `cd frontend && npm run dev`\n*   **Smart Contract Deployment:**\n    *   Use Hardhat or Foundry.\n    *   Compile contracts.\n    *   Run deployment scripts, passing necessary constructor arguments (e.g., initial dev wallet, addresses for LoveDistributor).\n    *   Update ABI JSON files in `backend/abi/` and contract addresses in `frontend/lib/contracts.ts` and backend `config.ts` / `.env.local`.\n\n## 6. Roadmap & Future Improvements\n\n### Phase 0: Project Understanding (Current)\n*   Comprehensive review of existing frontend, backend, and smart contract (`LilnadNFT.sol`, `LoveToken.sol`, `LoveDistributor.sol`) architecture and interactions.\n\n### Phase 1: Smart Contract Hardening & Core Adjustments (Testnet Focus)\n*   **Security Enhancements for `LilnadNFT.sol` Minting:**\n    *   Refine Commit-Reveal: Include `block.timestamp` in commitment hash.\n    *   Randomness Generation: Combine `blockhash(commitBlockNumber)`, `block.prevrandao`, `msg.sender`, `salt`, and `commitTimestamp`.\n    *   Expired Commits: Implement penalty (lowest rank NFT) for late reveals.\n    *   Security Review: Re-evaluate ReentrancyGuards, Ownable access, input validations.\n*   **Adjust Bulk Mint Options in `LilnadNFT.sol` & Frontend:**\n    *   Retain: Single mint, Pack 10+1, Pack 25+3.\n    *   Remove: Pack 50+6, Pack 100+12.\n*   **Backend Indexer Improvement:**\n    *   **Crucial:** Implement indexing for ERC721 `Transfer` events in `indexer.ts` to ensure `ownerAddress` in the database is always accurate.\n\n### Phase 2: Data Fetching Optimization & UX Enhancements (Testnet Focus)\n*   **Smart Contract View Functions for `LilnadNFT.sol`:**\n    *   Verify/refine `getNftsSummary(address _owner)` (returns total live count & counts by rank).\n    *   Implement/refine `getOwnedLiveTokenIds(address _owner)` (returns array of live token IDs for an owner).\n    *   Implement `getNftDetails(uint256 tokenId)` (returns detailed SBTInfo, calculated expiration, collectable score).\n*   **Frontend Data Fetching Overhaul:**\n    *   **World Page:** Utilize `getNftsSummary` directly from the smart contract.\n    *   **Collect Page:**\n        1.  Fetch all live token IDs using `getOwnedLiveTokenIds`.\n        2.  Implement client-side pagination for these IDs.\n        3.  For currently displayed token IDs, fetch detailed data (`sbtInfo`, `tokenURI`, `rankData`) directly from smart contract view functions (consider batching if possible).\n        4.  Perform `calculated` field computations on the frontend.\n*   **Implement `collectAll()` in `LilnadNFT.sol` & Frontend:**\n    *   Consider gas limits by batching collects if a user has many NFTs.\n*   **Display NFT Expiration Info in UI:**\n    *   Use `getNftDetails` to show "Time Remaining" or "Expired On" in `SbtCard` and World page details.\n\n### Phase Future: Full Reward System & Mainnet Launch\n*   **Off-Chain Reward Calculation Scripts:**\n    *   Develop scripts for: Weekly score snapshots, Top 70% player identification, Tiered lottery prize assignment, Merkle Root generation for `LoveDistributor`.\n*   **Smart Contract Adjustments (if needed for rewards):**\n    *   View functions in `LilnadNFT.sol` for easy off-chain score querying.\n    *   Ensure seamless MON transfer m√©canismes from `LilnadNFT.devPool` to `LoveDistributor`.\n*   **Deployment & Configuration:**\n    *   Deploy `LoveToken.sol`, `LoveDistributor.sol`.\n    *   Correctly set ownership and contract links (e.g., LoveToken owner is LoveDistributor).\n*   **Frontend for Reward Claims:**\n    *   UI for users to claim LOVE rewards using Merkle proofs.\n    *   Display current season info, claimable rewards, claim history.\n*   **Liquidity Pool Management:**\n    *   Process for owner to withdraw MON & LOVE from `LoveDistributor` and add to DEX LP.\n*   **Comprehensive Testing & Security Audit:** Before Mainnet launch.\n*   **Mainnet Deployment Strategy.**\n\n## 7. API Reference (Summary)\n\n*   **GET `/api/nfts/owner/:ownerAddress?page=<num>&limit=<num>`:**\n    *   Returns paginated list of a user\'s Lilnad NFTs with enriched on-chain data and calculated SBT properties.\n*   **GET `/api/metadata/lilnad/:tokenId`:**\n    *   Returns ERC721 compliant JSON metadata for a specific Lilnad NFT.\n*   **GET `/leaderboard`:**\n    *   (Current/Planned) Returns leaderboard data (e.g., top scores from snapshots).\n\n## 8. Smart Contract ABI & Address\n\n*   **ABI:** Located in `backend/abi/LilnadNFT.json` (and potentially `LoveToken.json`, `LoveDistributor.json` in the future).\n*   **Addresses:** Configured via environment variables (`LILNAD_NFT_ADDRESS`, etc.) and typically imported into frontend code from a path like `@/lib/contracts`.\n\n---\n*This document is a live overview and will be updated as the project progresses.* 